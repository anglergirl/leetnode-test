[TOC]

## 回溯算法遍历过程
![avatar](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)
```
void backtracking(参数) {
  if(终止条件) {
      存放结果；
      return;
  }

  for(选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
      处理节点；
      backtracking(路径，选择列表);
      回溯，撤销处理结果；
  }
}
```
## 组合
[组合](https://leetcode.cn/problems/combinations/description/)

将组合问题抽象为下图的树形结构
![avatar](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。图中可以发现n相当于树的宽度，k相当于树的深度。

### 回溯法三部曲
#### 递归函数的返回值以及参数
定义两个全局变量，一个用来存放符合条件的单一结果，一个用来存放符合条件结果的集合

``
  vector<int>  path;
  vector<vector<int>> result;
``

函数中一定包含两个参数，集合n中取k个数，所以n和k是两个int型参数
还需要一个int型变量startIndex，用来记录本层递归中，集合从哪里开始遍历。(需要startIndex来记录下一层递归，搜索的起始位置)

``
  void backtracking(int n, int k, int startIndex);
``
#### 回溯函数终止条件(到达叶子节点)
path这个数组的大小如果到达了k，此时已经找到了子集大小为k的组合
![avatar](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195407907.png)
此时用result二维数组把path保存起来，并终止本层递归。

```
  if(path.size() == k) {
      result.push_back(path);
      return;
  }
```

#### 单层搜索过程
回溯法的搜索过程就是一个树型结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历。

```
  for(int i = startIndex; i <= n; i++) {
     path.push_back(i);
     backtracking(n, k, i + 1);
     path.pop_back();
  }
```

### 剪枝优化
例如， n = 4, k = 4，从第一层for循环的时候，元素2就已经没有意义了。在第二层for循环时，元素3没有意义。
** 所以可以剪枝的地方就在递归中每一层的for循环所选的起始位置 **。
如果for循环选择的起始位置之后的元素个数已经不足需要的元素个数了，就没有必要搜索了。

优化过程：
  已经选择的元素个数：path.size()
  还需要的元素个数： k - path.size()
  在集合n中至多要从起始位置：n - (k - path.size()) + 1开始遍历。
  
